\section{Knowledge Graph Construction with Declarative Mapping Rules \textcolor{red}{By 12/1}}
\label{sec:chp2_declarative_kgc}

Knowledge graphs can be constructed in diverse manners. One way comprises collecting knowledge from contributions form the community, such as Wikidata. Other way involves transforming data from heterogeneous formats and sources, unstructured or (semi-)structured, into RDF. This section focuses on providing an overview of the latter, to declaratively construct knowledge graphs from heterogeneous data sources.

%\ana{overview de distintas formas y métodos en general de construir KGs. Debería ser algo larga, ampliando lo que hay en la intro. Luego terminar con enfocarse en los approaches declarativos, que se extienden en la siguiente subsección}

%\ana{RAW} In this section, the current scene of mapping languages is described first, regardless of the approach they follow, i.e., RDF materialization or virtualization. Then, previous works comparing mapping languages are surveyed. 


Constructing RDF knowledge graphs from heterogeneous data sources involve a schema transformation of the data to the desired graph structure. This transformation may be done in several different ways, usually involving mapping languages that allow expressing the transformation rules to create the target graphs. Hence, these mappings hold declaratively the relationships between the source and target data schemas. This comprises an agnostic approach that can (and has been) applied to multiple different use cases. \ana{refs}

The usual workflow in which declarative approaches are involved is depicted in \cref{fig:chp2_kgc-workflow}. They enable both materialization and virtualization of knowledge graphs. In materialization scenarios, data is transformed into the target graph, usually following the schema provided by an ontology. In virtualization scenarios, data is not transformed; instead, the original data source is accessed also following the schema of the target (virtual) graph. This process requires translating the original query into the language of the original data source. \ana{mention OBDA?}

\begin{figure*}[h]
\centering
\includegraphics[width=0.9\linewidth]{figures/chp2_kgc-workflow.pdf}
\caption[Declarative knowledge graph construction workflow]{Declarative knowledge graph construction workflow.}
\label{fig:chp2_kgc-workflow}
\end{figure*}

This section presents an overview of existing mapping languages. We first show two RDF-based mapping languages that have had a significant impact, the W3C Recommendation R2RML (\cref{sec:chp2_R2RML}), and its most impactful extension, RML (\cref{sec:chp2_RML}); and then other relevant languages (\cref{sec:chp2_more-languages}). Lastly, we discuss the approaches that compare the diversity and expressiveness of these mapping languages (\cref{sec:chp2_language-comparison}).






\subsection{R2RML: RDB to RDF Mapping Language}
\label{sec:chp2_R2RML}

R2RML~\parencite{das2012r2rml} addresses the transformation of data in relational databases into RDF. This language specifies to write the transformation rules in R2RML mapping documents. An R2RML mapping document is composed by at least one \textit{Triples Map} (\texttt{rr:TriplesMap}). \textit{Triples Maps} are used to define the transformation rules to generate RDF triples, their structure is depicted in \cref{fig:chp2_r2rml-tm}. It contains:

\begin{itemize}
    \item One \textit{Logical Table} (\texttt{rr:LogicalTable}), that describes the source relational table or view of a database.
    \item One \textit{Subject Map} (\texttt{rr:SubjectMap}), that defines how to generate the subject of the triples, and optionally, the corresponding class(es) it may be instance of (\texttt{rr:class}).
    \item Zero to multiple \textit{Predicate Object Maps} (\texttt{rr:PredicateObjectMap}). A \textit{Predicate Object Map} (POM) is formed by one to multiple \textit{Predicate Maps} (\texttt{rr:PredicateMap}), and one to many \textit{Object Maps} (\texttt{rr:ObjectMap}).% or \textit{Referencing Object Maps} (\texttt{rr:RefObjectMap}). The former is used for regular objects of triples, and the latter for creating as object the subject of another \textit{Triples Map}. 
\end{itemize}

Zero or more \textit{Graph Maps} (\texttt{rr:GraphMap}), which indicate how to generate named graphs, can be assigned to both \textit{Subject Maps} and \textit{Predicate Object Maps}. 
It is also possible to join \textit{Logical Tables} by replacing \textit{Object Map} by \texttt{Referencing Object Maps} (\texttt{rr:RefObjectMap}), which uses the subject of another \textit{Triples Map}, indicated with \texttt{rr:parentTriplesMap}, as the object of the triple. 
This join may have a condition to be performed, which is indicated using \texttt{rr:joinCondition}, \texttt{rr:child}, and \texttt{rr:parent}. 
Additionally, \textit{Object Maps} may include additional information, such as datatypes (\texttt{rr:datatype}) and languages (\texttt{rr:language}) of literals. 

\begin{figure*}[h]
\centering
\includegraphics[width=0.7\linewidth]{figures/chp2_r2rml_tm.pdf}
\caption[Structure of Triples Map from R2RML]{Structure of a \textit{Triples Map} and its properties (adapted from \cite{das2012r2rml}).}
\label{fig:chp2_r2rml-tm}
\end{figure*}

\textit{Subject Map}, \textit{Predicate Map}, \textit{Object Map}, and \textit{Graph Map} are subclasses of \textit{Term Map} (\texttt{rr:TermMap}), which define how to generate RDF terms. 
\textit{Term Maps} can be (i) \textit{constant-valued} (\texttt{rr:constant}), i.e., always generating the same RDF term; 
(ii) \textit{column-valued} (\texttt{rr:column}), i.e., the RDF terms are directly obtained from cells of a column in the RDB; 
or (iii) \textit{template-valued} (\texttt{rr:template}), i.e., the RDF terms are composed from the data in columns and constant strings. These terms can be generated either as IRIs (\texttt{rr:IRI}), Blank Nodes (\texttt{rr:BlankNode}) or literals (\texttt{rr:Literal}) using \texttt{rr:termType}. The structure of a \textit{Term Map} is shown in \cref{fig:chp2_r2rml-term}.


\begin{figure*}[t]
\centering
\includegraphics[width=0.45\linewidth]{figures/chp2_r2rml_term.pdf}
\caption[Structure of Triples Map from R2RML]{Structure of a \textit{Term Map} and its properties (adapted from \cite{das2012r2rml}).}
\label{fig:chp2_r2rml-term}
\end{figure*}



\cref{lst:chp2_r2rml-mapping} shows an example of an R2RML mapping to construct the RDF graph in \cref{lst:chp2_r2rml-result-rdf}. The R2RML mapping contains one \textit{Triples Map}, "TriplesMapAthletes" (Line 5). It takes as input the "Athletes" table shown in \cref{fig:chp2_database-example} (Line 6), which contains information about pole vault athletes, including their name, position in the ranking and height of a jump. The subject is formed with a template using one data source column (Line 8). The set of \textit{Predicate Object Maps} are used to describe with further attributes each instance (Lines 11-26). Two of them add the datatype to the object, one as an integer (Line 19) and other as a float (Line 25). 


\begin{figure*}[h]
\centering
\includegraphics[width=0.45\linewidth]{figures/chp2_database-example.pdf}
\caption[Input "Athletes" table]{Input "Athletes" table with names, ranks and marks for athletes.}
\label{fig:chp2_database-example}
\end{figure*}

\begin{captionedlisting}{lst:chp2_r2rml-mapping}{R2RML mapping to generate the RDF graph in \cref{lst:chp2_r2rml-result-rdf} with data from the database table shown in \cref{fig:chp2_database-example}.}
\centering
{\begin{lstlisting}[language=r2rml]
@prefix rr: <http://www.w3.org/ns/r2rml#>.
@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.
@prefix ex: <http://example.com/ns#>.

<#TriplesMapAthletes>
    rr:logicalTable [ rr:tableName "Athletes" ];
    rr:subjectMap [
        rr:template "http://example.com/athlete/{RANK}";
        rr:class ex:Athlete;
    ];
    rr:predicateObjectMap [
        rr:predicate ex:name;
        rr:objectMap [ rr:column "NAME" ];
    ];
    rr:predicateObjectMap [
        rr:predicate ex:rank;
        rr:objectMap [ rr:column "RANK" ; rr:datatype xsd:integer ];
    ];
    rr:predicateObjectMap [
        rr:predicate ex:mark;
        rr:objectMap [ rr:column "MARK" ; rr:datatype xsd:float ];
    ].
\end{lstlisting}}
\end{captionedlisting}

\begin{minipage}{\textwidth}
\begin{captionedlisting}{lst:chp2_r2rml-result-rdf}{RDF graph resulting from transforming data from the database table shown in \cref{fig:chp2_database-example} using the R2RML mapping in \cref{lst:chp2_r2rml-mapping}.}
\centering
\begin{multicols}{2}
{\begin{lstlisting}[language=r2rml]
ex:athlete/1 a ex:Athlete ;
    ex:name "Armand Duplantis" ;
    ex:rank "1"^^xsd:integer ;
    ex:mark "6.22"^^xsd:float .
ex:athlete/2 a ex:Athlete ;
    ex:name "Sondre Guttormsen" ;
    ex:rank "2"^^xsd:integer ;
    ex:mark "6.00"^^xsd:float .
ex:athlete/3 a ex:Athlete ;
    ex:name "Menno Vloon" ;
    ex:rank "3"^^xsd:integer ;
    ex:mark "5.91"^^xsd:float .
\end{lstlisting}}
\end{multicols}
\end{captionedlisting}
\end{minipage}



 
\subsection{RML: RDF Mapping Language}
\label{sec:chp2_RML}
RML~\parencite{Dimou2014rml} extends R2RML to address the transformation of heterogeneous data formats, such as CSV, XML or JSON. Broadening the possibilities for KG construction with minimal changes in the vocabulary with respect to the standard, this language rapidly gained importance, and currently gathers an active community of users and developers. 

The main differences of RML with R2RML~\parencite{dimou2020rml-r2rml-diffs} are listed as follows:
\begin{itemize}
    \item \textbf{Data source reference}. RML introduces the \textit{Logical Source} (\texttt{rml:LogicalSource}), that extends R2RML's \textit{Logical Table}. Where the \textit{Logical Table} focuses on relational databases, the \textit{Logical source} enables the description of more heterogeneous data sources in addition to relational databases.

    \item \textbf{Data source language}. In R2RML, the data source language is implicitly assumed to be SQL. To address heterogeneous data formats, RML uses the \textit{Reference Formulation} (\texttt{rml:ReferenceFormulation}) to indicate which formulation is suitable to parse data in a specific format. For instance, the JSONPath formation can be used for parsing data in a JSON file. 

    \item \textbf{Iteration}. For tabular data sources, the iteration of the data source is per row. This strategy is followed by every R2RML processor to construct RDF graphs from RDBs. For non-tabular data sources, the iteration cannot always be implicitly assumed. For this reason, RML introduces the \textit{Iterator} (\texttt{rml:iterator})enabling the explicit determination of the iteration pattern to specify the specific data used in each iteration to build the RDF triples. The use of the \textit{Iterator} is optional, its use relies on the needs and particularities of each data source and use case.

    \item \textbf{Value reference}. R2RML relies on column names when referring to values in a table or view of a RDB (\texttt{rr:column}). RML broadens the scope of this concept using \textit{References} (\texttt{rml:reference}), that may refer to columns, objects (such as in the case of XML and JSON) or other elements valid with respect to the used \textit{Reference Formulation}. 
\end{itemize}


\cref{lst:chp2_rml-mapping} shows an example RML mapping that generates the same output RDF graph (\cref{lst:chp2_r2rml-result-rdf}) as the R2RML mapping previously shown in \cref{lst:chp2_r2rml-mapping}. Instead of a database table, this mapping takes as input a JSON file (\cref{lst:chp2_json-example}), which is described with the \textit{Logical Source)} (Lines 6-19). The fields of the input JSON file are referred to using the \texttt{rml:reference} property. 

\begin{minipage}{\textwidth}
\begin{captionedlisting}{lst:chp2_json-example}
{Input "Athletes.json" file with names, ranks and marks for athletes.}
\centering
\begin{multicols}{2}
{\begin{lstlisting}[]
[ { "NAME": "Duplantis",
    "RANK": "1",
    "MARK": "6.22"},
  { "NAME": "Guttormsen",
    "RANK": "2",  
    "MARK": "6.00"},
  { "NAME": "Vloon",
    "RANK": "3",
    "MARK": "5.91"} ]
\end{lstlisting}}
\end{multicols}
\end{captionedlisting}
\end{minipage}


\begin{captionedlisting}{lst:chp2_rml-mapping}{RML mapping to generate the RDF graph in \cref{lst:chp2_r2rml-result-rdf} with data from the JSON file shown in \cref{lst:chp2_json-example}.}
\centering
{\begin{lstlisting}[language=r2rml]
@prefix rr: <http://www.w3.org/ns/r2rml#>.
@prefix rml: <http://semweb.mmlab.be/ns/rml#>.
@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.
@prefix ex: <http://example.com/ns#>.

<#TriplesMapAthletes>
  rml:logicalSource [
    rml:source "Athletes.json";
    rml:referenceFormulation ql:JSONPath;
    rml:iterator "$\dollar$.*"
  ];
    rr:subjectMap [
        rr:template "http://example.com/athlete/{RANK}";
        rr:class ex:Athlete;
    ];
    rr:predicateObjectMap [
        rr:predicate ex:name;
        rr:objectMap [ rml:reference "NAME" ];
    ];
    rr:predicateObjectMap [
        rr:predicate ex:rank;
        rr:objectMap [ rml:reference "RANK" ; rr:datatype xsd:integer ];
    ];
    rr:predicateObjectMap [
        rr:predicate ex:mark;
        rr:objectMap [ rml:reference "MARK" ; rr:datatype xsd:float ];
    ].
\end{lstlisting}}
\end{captionedlisting}

Several proposals have been proposed for RML in the following years of its release to extend its capabilities. The initial features for addressing heterogeneous data sources were expanded by~\cite{Dimou2015Machine}, allowing more diverse data accesses and fine-grained description of the data sources. \cite{DeMeester2017fno_dbpedia} proposed \textbf{RML+FnO}, which provided RML with a connector to the Function Ontology~\parencite{demeester2016fno} to include data transformation functions in the mappings. \cite{delva2021rml-fields} introduced the \textbf{RML Fields}, that addressed several challenges to accurately access nested data. \textbf{RML Target} was developed by \cite{VanAssche2021LeveragingWebThings} to specify how to create the output triples regarding, for instance, RDF serialization, compression format or encoding. Lastly, \textbf{RML-star} was proposed by \cite{delva2021rml-star}, and later refined by \cite{arenas2023morphstar}, to allow the construction of RDF-star graphs. 

Recently, the Knowledge Graph Construction W3C Community Group\footnote{\url{https://www.w3.org/community/kg-construct/}} gathered these variety of specifications and released a new version of RML~\parencite{iglesias2023rml}, which includes several of these extensions, overcoming the identified limitations for declarative knowledge graph construction.




\subsection{Additional Mapping Languages}
\label{sec:chp2_more-languages}

Following, we present an overview of existing mapping languages, listed in \cref{tab:chp2_languages_summary} and depicted in  \cref{fig:chp2_mapping_languages}. This section presents additional relevant languages classified in three categories, based on the schema they are based on or extend: (i)~RDF-based, (ii)~SPARQL-based, and (iii)~based on alternative schemas.


\begin{table}[t]
\caption[Mapping languages overview]{Analyzed mapping languages and their corresponding references.}
\label{tab:chp2_languages_summary}
\resizebox{\columnwidth}{!}{
\begin{tabular}{ccc}
%\rowcolor[HTML]{EFEFEF} 
\textbf{Classification}                 & \textbf{Language}        & \textbf{Reference(s)} \\ \midrule
\multirow{15}{*}{\textbf{RDF-based}}   & D2RQ            & \parencite{bizer2004d2rq,d2rq}\\ \cmidrule{2-3} 
                              & R$_2$O          & \parencite{barrasa2004r2o}\\ \cmidrule{2-3} 
                              & R2RML           & \parencite{das2012r2rml}\\ \cmidrule{2-3} 
                              & xR2RML          & \parencite{michel2015xr2rml,xr2rml}\\ \cmidrule{2-3} 
                              & RML             & \parencite{Dimou2014rml,rml}\\ \cmidrule{2-3} 
                              & KR2RML          & \parencite{slepicka2015kr2rml}\\ \cmidrule{2-3} 
                              & FunUL           & \parencite{junior2016funul}\\ \cmidrule{2-3} 
                              & R2RML-F         & \parencite{debruyne2016r2rmlf}\\ \cmidrule{2-3} 
                              & D2RML           & \parencite{chortaras2018d2rml}\\ \cmidrule{2-3} 
                              & R2RML for collections & \parencite{debruyne2017R2RML-collections}\\ \cmidrule{2-3}   
                              & XLWrap          & \parencite{langegger2009xlwrap,xlwrap}\\ \cmidrule{2-3} 
                              & CSVW            & \parencite{Tennison2015csvw}\\ \midrule
\multirow{6}{*}{\textbf{SPARQL-based}} & SPARQL-Generate &     
                              \parencite{Lefrancois2017sparqlgenerate,sparqlgenerate}\\ \cmidrule{2-3} 
                              & XSPARQL         & \parencite{Bischof2012xsparql,xsparql}\\ \cmidrule{2-3} 
                              & TARQL           & \parencite{tarql}\\ \cmidrule{2-3}
                              & Facade-X        & \parencite{asprino2023sparql-anything,sparqlanything}\\ \cmidrule{2-3}
                              & \textcolor{red}{Sansa}            & \parencite{stadler2023spark}\\ \midrule
\multirow{4}{*}{\textbf{Alternative schema}}       & Helio mappings  & \parencite{cimmino2022helio}\\ \cmidrule{2-3} 
                              & D-REPR          & \parencite{Vu2019d-repr}\\ \cmidrule{2-3} 
                              & ShExML          & \parencite{Garcia-Gonzalez2020shexml,shexml}\\  \bottomrule
\end{tabular}}
\end{table}



\begin{figure*}[t]
\centering
\includegraphics[width=1\linewidth]{figures/chp2_mapping_languages}
\caption[Existing mapping languages and the relationships among them]{Mapping languages developed in the last two decades, classified according to the schema they are based on, and the relationships among them.}
\label{fig:chp2_mapping_languages}
\end{figure*}




\subsubsection{RDF-based mapping languages.} 
\label{sec:chp2_RDF-languages}

Mapping languages in this group are formalized using RDF. They are usually modelled as ontologies or vocabularies that enable the description of data transformation rules. Mappings that follow these languages are usually written in files following the Turtle syntax~\parencite{turtle}. R2RML and RML, previously presented in \cref{sec:chp2_R2RML}
and \cref{sec:chp2_RML} respectively, also belong to this group of languages. 


\noindent\textbf{D2RQ}~\parencite{bizer2004d2rq} is one of the first mapping languages, developed to access the content of non RDF relational databases. The main components of this language are the \textit{Class Map} (\texttt{d2rq:ClassMap}) and the \textit{Property Bridge} (\texttt{d2rq:PropertyBridge})~\parencite{d2rq}. A \textit{Class Map} specifies how the instances of a class are generated, indicating the class that the instances belong to, the database's column(s) and URI pattern to create the URI for the instances. Each \textit{Class Map} also specifies the access to the input database, and refer to \textit{Property Bridges}. These \textit{Property Bridges} are used to generate the pairs of predicate-objects for the \textit{Class Map}, specifying the property for the predicate, and patterns and column references for the object. 


\noindent\textbf{XLWrap}~\parencite{langegger2009xlwrap} enables the transformation of spreadsheets to RDF. These mappings are written using the TriG syntax. They contain a graph instance of \texttt{xl:Mapping}, that describes the input file (workbook) (\texttt{xl:fileName}) and worksheet (\texttt{xl:sheetName}), a constant graph with information about the mapping (\texttt{xl:constantGraph}), references to \textit{Template Graphs} (\texttt{xl:templateGraph}) and \textit{Transformation Operations} (\texttt{xl:transformationOperation}). The \textit{Template Graphs} specify how to create the desired RDF graphs with references from the spreadsheet's cells and XLWrap expressions. This language provides further features to accurately access data in spreadsheets, described in the specification~\parencite{xlwrap}.  

\noindent\textbf{KR2RML}~\parencite{slepicka2015kr2rml} extended R2RML to: (i) address multiple input data formats, such as CSV, JSON and XML; (ii) select the RDF serialization to create the output graph and (iii) integrate data transformation functions for pre-processing messy data without relying on SQL queries or views. To this end, the authors developed the nested Relational Model (NRM), as an intermediate form to represent data. NRM allowed the unification of the way to access data without loosing expressiveness. 

\noindent\textbf{xR2RML}~\parencite{michel2015xr2rml} extends R2RML and RML to include additional heterogeneous data sources and additional features not usually tackled by other mapping languages. It extends RML's \textit{Logical Source} to include NoSQL databases (e.g. MongoDB), and refines the access to different levels of iterations for hierarchical data sources with \texttt{xrr:pushDown}. It enables the creation of RDF lists and containers, by including additional \textit{Term Map} types (\texttt{xrr:RdfList}, \texttt{xrr:RdfSeq}, \texttt{xrr:RdfBag} and \texttt{xrr:RdfAlt}). Additionally, it allows the creation of dynamic language tags (i.e., with references from the input data) with \texttt{xrr:languageReference}.

\noindent\textbf{R2RML-F}~\parencite{debruyne2016r2rmlf} is a dedicated extension of R2RML to include data transformation functions, later refined in \textbf{FunUL}~\parencite{junior2016funul}. It introduces the \textit{Function} class (\texttt{rrf:Function}), which defines a data transformation function with name and body. An additional type of \textit{Term Map} is defined, the \textit{Function Valued Term Map}, which connects with the \textit{Function} and supplies it with parameter bindings. 

\noindent\textbf{R2RML for collections and containers}~\parencite{debruyne2017R2RML-collections} is another R2RML extensions focused on the generation of RDF lists and containers. These terms are created with \textit{Gather Maps}, that create a group of \textit{Object Maps} within an \textit{Object Map} with the \texttt{rrf:gather} property. 

\noindent\textbf{D2RML}~\parencite{chortaras2018d2rml} proposes a vocabulary extension to R2RML and RML with a large amount of features to describe in detail different heterogeneous data formats (e.g., JSON, CSV, XML) and accesses (e.g., RESTful APIs, SPARQL endpoints, documents) with a high level of detail. For instance, it adds to R2RML's \textit{Logical Table} and RML's \textit{Logical Source} the \textit{SQL Tables}, \textit{SPARQL Tables}, \textit{CSV Tables} and \textit{Information Source}. This proposal also includes data transformation functions to be used within the data source descriptions, and enables conditional generation of \textit{Term Maps}. 

\noindent\textbf{CSV on the Web (CSVW)}~\parencite{Tennison2015csvw} is a W3C Recommendation that enables a fine-grained annotation of CSV files and other tabular data formats, such as datatypes, valid values, data transformations, and primary and foreign key constraints. 




\subsubsection{SPARQL-based mapping languages.}
\label{sec:chp2_SPARQL-languages} 

This group is integrated by languages that leverage the SPARQL query language, usually by extending its features to describe non-RDF data sources~\parencite{harris2013sparql}. 


\noindent\textbf{XSPARQL}~\parencite{Bischof2012xsparql}

\noindent\textbf{SPARQL-Generate}~\parencite{Lefrancois2017sparqlgenerate}

\noindent\textbf{TARQL}~\parencite{tarql}

\noindent\textbf{SPARQL-Anything}~\parencite{asprino2023sparql-anything}

\noindent\textbf{Sansa/whatever}~\parencite{stadler2023spark}




\textit{XSPARQL~\parencite{Bischof2012xsparql} merges SPARQL and XQuery to transform XML into RDF. TARQL~\parencite{tarql} uses the SPARQL syntax to generate RDF from CSV files. SPARQL-Generate~\parencite{Lefrancois2017sparqlgenerate} is capable of generating RDF and document streams from a wide variety of data formats and access protocols. Most recently, Facade-X has been developed, not as a new language, but as a "\textit{facade} to wrap the original resource and to make it queryable as if it was RDF"~\parencite{asprino2023sparql-anything}. It does not extend the SPARQL language, instead it overrides the SERVICE operator. Lastly, authors would like to highlight a loosely SPARQL-based language, Stardog Mapping Syntax 2 (SMS2)~\parencite{sms2}, which represents virtual Stardog graphs and is able to support sources such as JSON, CSV, RDB, MongoDB and Elasticsearch.}




\subsubsection{Based on alternative schemas.} 
\label{sec:chp2_alternative-languages}

Lastly, the languages of this group rely on schemas different from RDF or SPARQL, equally able and expressive enough to enable users to write transformation rules. 


\noindent\textbf{R$_2$O}~\parencite{barrasa2004r2o} XML-based~\footnote{https://pdfs.semanticscholar.org/4c47/0826aafc07fc6d37ca7e2474c1d3b290ade1.pdf}

\noindent\textbf{D-REPR}~\parencite{Vu2019d-repr}

\noindent\textbf{ShExML}~\parencite{Garcia-Gonzalez2020shexml,garcia2021shexml-challenges}

\noindent\textbf{Helio??}~\parencite{cimmino2022helio}

\textit{ShExML~\parencite{Garcia-Gonzalez2020shexml,garcia2021shexml-challenges} uses Shape Expressions (ShEx)~\parencite{prud2014shex} to map data sources in RDBs, CSV, JSON, XML and RDF using SPARQL queries. The Helio mapping language~\parencite{cimmino2022helio} is based on JSON and provides the capability of using functions for data transformation and data linking~\parencite{cimmino2018hybrid}. D-REPR~\parencite{Vu2019d-repr} focuses on describing heterogeneous data with JSONPath and allows the use of data transformation functions. XRM (Expressive RDF Mapper)~\parencite{xrm} is a commercial language that provides a unique user-friendly syntax to create mappings in R2RML, CSVW and RML.}










\subsection{Mapping Languages Comparison}
\label{sec:chp2_language-comparison}

As the number of mapping languages increased and their adoption grew wider, comparisons between these languages inevitably occurred. This is the case of, for instance, SPARQL-Generate~\parencite{Lefrancois2017sparqlgenerate}, which is compared to RML in terms of query/mapping complexity; and ShExML~\parencite{Garcia-Gonzalez2020shexml}, which is compared to SPARQL-Generate and YARRRML from a usability perspective.

Some studies dig deeper, providing qualitative complex comparison frameworks. Hert et al.~\parencite{hert2011comparison} provide a comparison framework for mapping languages focused on transforming relational databases to RDF. The framework is composed of 15 features, and the languages are evaluated based on the presence or absence of these features.% (Logical table to class, M:N relationships, project attributes, select conditions, user-defined instance URIs, literal to URIs, vocabulary reuse, transformation functions, datatypes, named graphs, blank nodes, integrity constraints, static metadata, one table to \textit{n} classes, and write support). 
The results lead authors to divide the mappings into four categories (direct mapping, read-only general-purpose mapping, read-write general-purpose mapping, and special-purpose mapping), and ponder on the heavy reliance of most languages on SQL to implement the mapping, and the usefulness of read-write mappings (i.e., mappings able to write data in the database). De Meester et al.~\parencite{DeMeester2019comparison} show an initial analysis of 5 similar languages (RML+FnO, xR2RML, FunUL, SPARQL-Generate, YARRRML) discussing their characteristics, according to three categories: non-functional, functional and data source support. The study concludes by remarking on the need to build a more complete and precise comparative framework and asking for a more active participation from the community to build it. To the best of our knowledge, there is no comprehensive work in the literature comparing all existing languages. \ana{ojo con esto que con el survey de ghent ya no es del todo cierto :(} 
